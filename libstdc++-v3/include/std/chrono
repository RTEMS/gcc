// <chrono> -*- C++ -*-

// Copyright (C) 2008-2020 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/chrono
 *  This is a Standard C++ Library header.
 *  @ingroup chrono
 */

#ifndef _GLIBCXX_CHRONO
#define _GLIBCXX_CHRONO 1

#pragma GCC system_header

#if __cplusplus < 201103L
# include <bits/c++0x_warning.h>
#else

#include <ratio>
#include <type_traits>
#include <limits>
#include <ctime>
#include <bits/parse_numbers.h> // for literals support.
#if __cplusplus > 201703L
# include <concepts>
# include <compare>
#endif

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if __cplusplus >= 201703L
  namespace filesystem { struct __file_clock; };
#endif

  /**
   * @defgroup chrono Time
   * @ingroup utilities
   *
   * Classes and functions for time.
   * @{
   */

  /** @namespace std::chrono
   *  @brief ISO C++ 2011 namespace for date and time utilities
   */
  namespace chrono
  {
    template<typename _Rep, typename _Period = ratio<1>>
      struct duration;

    template<typename _Clock, typename _Dur = typename _Clock::duration>
      struct time_point;
  }

  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)

  /// @cond undocumented

  template<typename _CT, typename _Period1, typename _Period2, typename = void>
    struct __duration_common_type
    { };

  template<typename _CT, typename _Period1, typename _Period2>
    struct __duration_common_type<_CT, _Period1, _Period2,
				  __void_t<typename _CT::type>>
    {
    private:
      using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;
      using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;
      using __cr = typename _CT::type;
      using __r = ratio<__gcd_num::value,
			(_Period1::den / __gcd_den::value) * _Period2::den>;

    public:
      using type = chrono::duration<__cr, __r>;
    };

  template<typename _Period1, typename _Period2>
    struct __duration_common_type<__failure_type, _Period1, _Period2>
    { typedef __failure_type type; };

  /// @endcond

  /// Specialization of common_type for chrono::duration types.
  /// @relates duration
  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
    struct common_type<chrono::duration<_Rep1, _Period1>,
		       chrono::duration<_Rep2, _Period2>>
    : __duration_common_type<common_type<_Rep1, _Rep2>, _Period1, _Period2>
    { };

  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)

  /// @cond undocumented

  template<typename _CT, typename _Clock, typename = void>
    struct __timepoint_common_type
    { };

  template<typename _CT, typename _Clock>
    struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>>
    {
      using type = chrono::time_point<_Clock, typename _CT::type>;
    };

  /// @endcond

  /// Specialization of common_type for chrono::time_point types.
  /// @relates time_point
  template<typename _Clock, typename _Duration1, typename _Duration2>
    struct common_type<chrono::time_point<_Clock, _Duration1>,
		       chrono::time_point<_Clock, _Duration2>>
    : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock>
    { };

  // @} group chrono

  namespace chrono
  {
    /// @addtogroup chrono
    /// @{

    /// @cond undocumented

    // Primary template for duration_cast impl.
    template<typename _ToDur, typename _CF, typename _CR,
	     bool _NumIsOne = false, bool _DenIsOne = false>
      struct __duration_cast_impl
      {
	template<typename _Rep, typename _Period>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
	      * static_cast<_CR>(_CF::num)
	      / static_cast<_CR>(_CF::den)));
	  }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
      {
	template<typename _Rep, typename _Period>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(__d.count()));
	  }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
      {
	template<typename _Rep, typename _Period>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
	  }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
      {
	template<typename _Rep, typename _Period>
	  static constexpr _ToDur
	  __cast(const duration<_Rep, _Period>& __d)
	  {
	    typedef typename _ToDur::rep			__to_rep;
	    return _ToDur(static_cast<__to_rep>(
	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
	  }
      };

    template<typename _Tp>
      struct __is_duration
      : std::false_type
      { };

    template<typename _Rep, typename _Period>
      struct __is_duration<duration<_Rep, _Period>>
      : std::true_type
      { };

    template<typename _Tp>
      using __enable_if_is_duration
	= typename enable_if<__is_duration<_Tp>::value, _Tp>::type;

    template<typename _Tp>
      using __disable_if_is_duration
	= typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;

    /// @endcond

    /// duration_cast
    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      duration_cast(const duration<_Rep, _Period>& __d)
      {
	typedef typename _ToDur::period				__to_period;
	typedef typename _ToDur::rep				__to_rep;
	typedef ratio_divide<_Period, __to_period> 		__cf;
	typedef typename common_type<__to_rep, _Rep, intmax_t>::type
	  							__cr;
	typedef  __duration_cast_impl<_ToDur, __cf, __cr,
				      __cf::num == 1, __cf::den == 1> __dc;
	return __dc::__cast(__d);
      }

    /// treat_as_floating_point
    template<typename _Rep>
      struct treat_as_floating_point
      : is_floating_point<_Rep>
      { };

#if __cplusplus > 201402L
    template <typename _Rep>
      inline constexpr bool treat_as_floating_point_v =
        treat_as_floating_point<_Rep>::value;
#endif // C++17

#if __cplusplus > 201703L

  namespace __detail
  {
    template<typename _Int>
      constexpr _Int
      __modulo(_Int __num, _Int __den)
      { return /*FIXME?*/__num % __den; }

    constexpr int
    __days_per_month[12]
    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    constexpr int
    __last_day[12]
    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  }

    template<typename _Tp>
      struct is_clock;

    template<typename _Tp>
      inline constexpr bool is_clock_v = is_clock<_Tp>::value;

#if __cpp_lib_concepts
    template<typename _Tp>
      struct is_clock : false_type
      { };

    template<typename _Tp>
      requires requires {
	typename _Tp::rep;
	typename _Tp::period;
	typename _Tp::duration;
	typename _Tp::time_point::clock;
	typename _Tp::time_point::duration;
	{ &_Tp::is_steady } -> same_as<const bool*>;
	{ _Tp::now() } -> same_as<typename _Tp::time_point>;
	requires same_as<typename _Tp::duration,
			 duration<typename _Tp::rep, typename _Tp::period>>;
	requires same_as<typename _Tp::time_point::duration,
			 typename _Tp::duration>;
      }
      struct is_clock<_Tp> : true_type
      { };
#else
    template<typename _Tp, typename = void>
      struct __is_clock_impl : false_type
      { };

    template<typename _Tp>
      struct __is_clock_impl<_Tp,
			     void_t<typename _Tp::rep, typename _Tp::period,
				    typename _Tp::duration,
				    typename _Tp::time_point::duration,
				    decltype(_Tp::is_steady),
				    decltype(_Tp::now())>>
      : __and_<is_same<typename _Tp::duration,
		       duration<typename _Tp::rep, typename _Tp::period>>,
	       is_same<typename _Tp::time_point::duration,
		       typename _Tp::duration>,
	       is_same<decltype(&_Tp::is_steady), const bool*>,
	       is_same<decltype(_Tp::now()), typename _Tp::time_point>>::type
      { };

    template<typename _Tp>
      struct is_clock : __is_clock_impl<_Tp>::type
      { };
#endif
#endif // C++20

#if __cplusplus >= 201703L
# define __cpp_lib_chrono 201611

    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      floor(const duration<_Rep, _Period>& __d)
      {
	auto __to = chrono::duration_cast<_ToDur>(__d);
	if (__to > __d)
	  return __to - _ToDur{1};
	return __to;
      }

    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      ceil(const duration<_Rep, _Period>& __d)
      {
	auto __to = chrono::duration_cast<_ToDur>(__d);
	if (__to < __d)
	  return __to + _ToDur{1};
	return __to;
      }

    template <typename _ToDur, typename _Rep, typename _Period>
      constexpr enable_if_t<
	__and_<__is_duration<_ToDur>,
	       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
	_ToDur>
      round(const duration<_Rep, _Period>& __d)
      {
	_ToDur __t0 = chrono::floor<_ToDur>(__d);
	_ToDur __t1 = __t0 + _ToDur{1};
	auto __diff0 = __d - __t0;
	auto __diff1 = __t1 - __d;
	if (__diff0 == __diff1)
	{
	    if (__t0.count() & 1)
		return __t1;
	    return __t0;
	}
	else if (__diff0 < __diff1)
	    return __t0;
	return __t1;
      }

    template<typename _Rep, typename _Period>
      constexpr
      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>
      abs(duration<_Rep, _Period> __d)
      {
	if (__d >= __d.zero())
	  return __d;
	return -__d;
      }
#endif // C++17

    /// duration_values
    template<typename _Rep>
      struct duration_values
      {
	static constexpr _Rep
	zero() noexcept
	{ return _Rep(0); }

	static constexpr _Rep
	max() noexcept
	{ return numeric_limits<_Rep>::max(); }

	static constexpr _Rep
	min() noexcept
	{ return numeric_limits<_Rep>::lowest(); }
      };

    /// @cond undocumented

    template<typename _Tp>
      struct __is_ratio
      : std::false_type
      { };

    template<intmax_t _Num, intmax_t _Den>
      struct __is_ratio<ratio<_Num, _Den>>
      : std::true_type
      { };

    /// @endcond

    /// duration
    template<typename _Rep, typename _Period>
      struct duration
      {
      private:
	template<typename _Rep2>
	  using __is_float = treat_as_floating_point<_Rep2>;

	// _Period2 is an exact multiple of _Period
	template<typename _Period2>
	  using __is_harmonic
	    = __bool_constant<ratio_divide<_Period2, _Period>::den == 1>;

      public:

	typedef _Rep						rep;
	typedef _Period 					period;

	static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
	static_assert(__is_ratio<_Period>::value,
		      "period must be a specialization of ratio");
	static_assert(_Period::num > 0, "period must be positive");

	// 20.11.5.1 construction / copy / destroy
	constexpr duration() = default;

	duration(const duration&) = default;

	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 3050. Conversion specification problem in chrono::duration
	template<typename _Rep2, typename = _Require<
		 is_convertible<const _Rep2&, rep>,
		 __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>
	  constexpr explicit duration(const _Rep2& __rep)
	  : __r(static_cast<rep>(__rep)) { }

	template<typename _Rep2, typename _Period2, typename = _Require<
		 __or_<__is_float<rep>,
		       __and_<__is_harmonic<_Period2>,
			      __not_<__is_float<_Rep2>>>>>>
	  constexpr duration(const duration<_Rep2, _Period2>& __d)
	  : __r(duration_cast<duration>(__d).count()) { }

	~duration() = default;
	duration& operator=(const duration&) = default;

	// 20.11.5.2 observer
	constexpr rep
	count() const
	{ return __r; }

	// 20.11.5.3 arithmetic
	constexpr duration
	operator+() const
	{ return *this; }

	constexpr duration
	operator-() const
	{ return duration(-__r); }

	_GLIBCXX17_CONSTEXPR duration&
	operator++()
	{
	  ++__r;
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR duration
	operator++(int)
	{ return duration(__r++); }

	_GLIBCXX17_CONSTEXPR duration&
	operator--()
	{
	  --__r;
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR duration
	operator--(int)
	{ return duration(__r--); }

	_GLIBCXX17_CONSTEXPR duration&
	operator+=(const duration& __d)
	{
	  __r += __d.count();
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR duration&
	operator-=(const duration& __d)
	{
	  __r -= __d.count();
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR duration&
	operator*=(const rep& __rhs)
	{
	  __r *= __rhs;
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR duration&
	operator/=(const rep& __rhs)
	{
	  __r /= __rhs;
	  return *this;
	}

	// DR 934.
	template<typename _Rep2 = rep>
	  _GLIBCXX17_CONSTEXPR
	  typename enable_if<!treat_as_floating_point<_Rep2>::value,
			     duration&>::type
	  operator%=(const rep& __rhs)
	  {
	    __r %= __rhs;
	    return *this;
	  }

	template<typename _Rep2 = rep>
	  _GLIBCXX17_CONSTEXPR
	  typename enable_if<!treat_as_floating_point<_Rep2>::value,
			     duration&>::type
	  operator%=(const duration& __d)
	  {
	    __r %= __d.count();
	    return *this;
	  }

	// 20.11.5.4 special values
	static constexpr duration
	zero() noexcept
	{ return duration(duration_values<rep>::zero()); }

	static constexpr duration
	min() noexcept
	{ return duration(duration_values<rep>::min()); }

	static constexpr duration
	max() noexcept
	{ return duration(duration_values<rep>::max()); }

      private:
	rep __r;
      };

    /// @relates duration @{

    /// The sum of two durations.
    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
				     duration<_Rep2, _Period2>>::type
      operator+(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() + __cd(__rhs).count());
      }

    /// The difference between two durations.
    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
				     duration<_Rep2, _Period2>>::type
      operator-(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
      }

    /// @}

    /// @cond undocumented

    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2
    // is implicitly convertible to it.
    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // 3050. Conversion specification problem in chrono::duration constructor
    template<typename _Rep1, typename _Rep2,
	     typename _CRep = typename common_type<_Rep1, _Rep2>::type>
      using __common_rep_t = typename
	enable_if<is_convertible<const _Rep2&, _CRep>::value, _CRep>::type;

    /// @endcond

    /// @relates duration @{

    /// Multiply a duration by a scalar value.
    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>
      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
	  __cd;
	return __cd(__cd(__d).count() * __s);
      }

    /// Multiply a duration by a scalar value.
    template<typename _Rep1, typename _Rep2, typename _Period>
      constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>
      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
      { return __d * __s; }

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
	  __cd;
	return __cd(__cd(__d).count() / __s);
      }

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr typename common_type<_Rep1, _Rep2>::type
      operator/(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__lhs).count() / __cd(__rhs).count();
      }

    // DR 934.
    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
	  __cd;
	return __cd(__cd(__d).count() % __s);
      }

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
				     duration<_Rep2, _Period2>>::type
      operator%(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__cd;
	return __cd(__cd(__lhs).count() % __cd(__rhs).count());
      }

    // comparisons

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator==(const duration<_Rep1, _Period1>& __lhs,
		 const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__ct;
	return __ct(__lhs).count() == __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator<(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<__dur1,__dur2>::type	__ct;
	return __ct(__lhs).count() < __ct(__rhs).count();
      }

#if __cpp_lib_three_way_comparison
    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      requires three_way_comparable<common_type_t<_Rep1, _Rep2>>
      constexpr auto
      operator<=>(const duration<_Rep1, _Period1>& __lhs,
		  const duration<_Rep2, _Period2>& __rhs)
      {
	using __ct = common_type_t<duration<_Rep1, _Period1>,
				   duration<_Rep2, _Period2>>;
	return __ct(__lhs).count() <=> __ct(__rhs).count();
      }
#else
    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator!=(const duration<_Rep1, _Period1>& __lhs,
		 const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs == __rhs); }
#endif

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator<=(const duration<_Rep1, _Period1>& __lhs,
		 const duration<_Rep2, _Period2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator>(const duration<_Rep1, _Period1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Rep1, typename _Period1,
	     typename _Rep2, typename _Period2>
      constexpr bool
      operator>=(const duration<_Rep1, _Period1>& __lhs,
		 const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs < __rhs); }

    /// @}

#ifdef _GLIBCXX_USE_C99_STDINT_TR1
# define _GLIBCXX_CHRONO_INT64_T int64_t
#elif defined __INT64_TYPE__
# define _GLIBCXX_CHRONO_INT64_T __INT64_TYPE__
#else
    static_assert(std::numeric_limits<unsigned long long>::digits >= 64,
	"Representation type for nanoseconds must have at least 64 bits");
# define _GLIBCXX_CHRONO_INT64_T long long
#endif

    /// nanoseconds
    using nanoseconds	= duration<_GLIBCXX_CHRONO_INT64_T, nano>;

    /// microseconds
    using microseconds	= duration<_GLIBCXX_CHRONO_INT64_T, micro>;

    /// milliseconds
    using milliseconds	= duration<_GLIBCXX_CHRONO_INT64_T, milli>;

    /// seconds
    using seconds	= duration<_GLIBCXX_CHRONO_INT64_T>;

    /// minutes
    using minutes	= duration<_GLIBCXX_CHRONO_INT64_T, ratio< 60>>;

    /// hours
    using hours		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;

#if __cplusplus > 201703L
    /// days
    using days		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;

    /// weeks
    using weeks		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;

    /// years
    using years		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;

    /// months
    using months	= duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;

    // CLASS DECLARATIONS
    class day;
    class month;
    class year;
    class weekday;
    class weekday_indexed;
    class weekday_last;
    class month_day;
    class month_day_last;
    class month_weekday;
    class month_weekday_last;
    class year_month;
    class year_month_day;
    class year_month_day_last;
    class year_month_weekday;
    class year_month_weekday_last;
    class nonexistent_local_time;
    class ambiguous_local_time;
    class time_zone;
    class tzdb;
    class tzdb_list;
    class leap;
    class link;

    struct last_spec
    {
      explicit last_spec() = default;
    };

    inline constexpr last_spec last{};

    const tzdb& get_tzdb();
    tzdb_list& get_tzdb_list();

    // CALENDAR COMPOSITION OPERATORS

    constexpr year_month
    operator/(const year& __y, const month& __m) noexcept;

    constexpr year_month
    operator/(const year& __y, int __m) noexcept;

    constexpr month_day
    operator/(const month& __m, const day& __d) noexcept;

    constexpr month_day
    operator/(const month& __m, int __d) noexcept;

    constexpr month_day
    operator/(int __m, const day& __d) noexcept;

    constexpr month_day
    operator/(const day& __d, const month& __m) noexcept;

    constexpr month_day
    operator/(const day& __d, int __m) noexcept;

    constexpr month_day_last
    operator/(const month& __m, last_spec) noexcept;

    constexpr month_day_last
    operator/(int __m, last_spec) noexcept;

    constexpr month_day_last
    operator/(last_spec, const month& __m) noexcept;

    constexpr month_day_last
    operator/(last_spec, int __m) noexcept;

    constexpr month_weekday
    operator/(const month& __m, const weekday_indexed& __wdi) noexcept;

    constexpr month_weekday
    operator/(int __m, const weekday_indexed& __wdi) noexcept;

    constexpr month_weekday
    operator/(const weekday_indexed& __wdi, const month& __m) noexcept;

    constexpr month_weekday
    operator/(const weekday_indexed& __wdi, int __m) noexcept;

    constexpr month_weekday_last
    operator/(const month& __m, const weekday_last& __wdl) noexcept;

    constexpr month_weekday_last
    operator/(int __m, const weekday_last& __wdl) noexcept;

    constexpr month_weekday_last
    operator/(const weekday_last& __wdl, const month& __m) noexcept;

    constexpr month_weekday_last
    operator/(const weekday_last& __wdl, int __m) noexcept;

    constexpr year_month_day
    operator/(const year_month& __ym, const day& __d) noexcept;

    constexpr year_month_day
    operator/(const year_month& __ym, int __d) noexcept;

    constexpr year_month_day
    operator/(const year& __y, const month_day& __md) noexcept;

    constexpr year_month_day
    operator/(int __y, const month_day& __md) noexcept;

    constexpr year_month_day
    operator/(const month_day& __md, const year& __y) noexcept;

    constexpr year_month_day
    operator/(const month_day& __md, int __y) noexcept;

    constexpr year_month_day_last
    operator/(const year_month& __ym, last_spec) noexcept;

    constexpr year_month_day_last
    operator/(const year& __y, const month_day_last& __mdl) noexcept;

    constexpr year_month_day_last
    operator/(int __y, const month_day_last& __mdl) noexcept;

    constexpr year_month_day_last
    operator/(const month_day_last& __mdl, const year& __y) noexcept;

    constexpr year_month_day_last
    operator/(const month_day_last& __mdl, int __y) noexcept;

    constexpr year_month_weekday
    operator/(const year_month& __ym, const weekday_indexed& __wdi) noexcept;

    constexpr year_month_weekday
    operator/(const year& __y, const month_weekday& __mwd) noexcept;

    constexpr year_month_weekday
    operator/(int __y, const month_weekday& __mwd) noexcept;

    constexpr year_month_weekday
    operator/(const month_weekday& __mwd, const year& __y) noexcept;

    constexpr year_month_weekday
    operator/(const month_weekday& __mwd, int __y) noexcept;

    constexpr year_month_weekday_last
    operator/(const year_month& __ym, const weekday_last& __wdl) noexcept;

    constexpr year_month_weekday_last
    operator/(const year& __y, const month_weekday_last& __mwdl) noexcept;

    constexpr year_month_weekday_last
    operator/(int __y, const month_weekday_last& __mwdl) noexcept;

    constexpr year_month_weekday_last
    operator/(const month_weekday_last& __mwdl, const year& __y) noexcept;

    constexpr year_month_weekday_last
    operator/(const month_weekday_last& __mwdl, int __y) noexcept;

    // OTHER CALENDAR OPERATORS

    constexpr year_month_day_last
    operator+(const year_month_day_last& __ymdl, const months& __dm) noexcept;

    constexpr year_month_day_last
    operator-(const year_month_day_last& __ymdl, const months& __dm) noexcept;

    constexpr year_month_day_last
    operator+(const year_month_day_last& __ymdl, const years& __y) noexcept;

    constexpr year_month_day_last
    operator-(const year_month_day_last& __ymdl, const years& __y) noexcept;

    constexpr year_month_weekday_last
    operator+(const year_month_weekday_last& __ymwdl,
	      const months& __dm) noexcept;
    constexpr year_month_weekday_last
    operator+(const months& __dm,
	      const year_month_weekday_last& __ymwdl) noexcept;
    constexpr year_month_weekday_last
    operator+(const year_month_weekday_last& __ymwdl,
	      const years& __dy) noexcept;
    constexpr year_month_weekday_last
    operator+(const years& __dy,
	      const year_month_weekday_last& __ymwdl) noexcept;
    constexpr year_month_weekday_last
    operator-(const year_month_weekday_last& __ymwdl,
	      const months& __dm) noexcept;
    constexpr year_month_weekday_last
    operator-(const year_month_weekday_last& __ymwdl,
	      const years& __dy) noexcept;

    constexpr weekday operator+(const weekday& __x, const days& __y) noexcept;
    constexpr weekday operator-(const weekday& __x, const days& __y) noexcept;
#endif // C++20

#undef _GLIBCXX_CHRONO_INT64_T

    /// time_point
    template<typename _Clock, typename _Dur>
      struct time_point
      {
	static_assert(__is_duration<_Dur>::value,
	    "duration must be a specialization of std::chrono::duration");

	typedef _Clock						clock;
	typedef _Dur						duration;
	typedef typename duration::rep				rep;
	typedef typename duration::period			period;

	constexpr time_point() : __d(duration::zero())
	{ }

	constexpr explicit time_point(const duration& __dur)
	: __d(__dur)
	{ }

	// conversions
	template<typename _Dur2,
		 typename = _Require<is_convertible<_Dur2, _Dur>>>
	  constexpr time_point(const time_point<clock, _Dur2>& __t)
	  : __d(__t.time_since_epoch())
	  { }

	// observer
	constexpr duration
	time_since_epoch() const
	{ return __d; }

	// arithmetic
	_GLIBCXX17_CONSTEXPR time_point&
	operator+=(const duration& __dur)
	{
	  __d += __dur;
	  return *this;
	}

	_GLIBCXX17_CONSTEXPR time_point&
	operator-=(const duration& __dur)
	{
	  __d -= __dur;
	  return *this;
	}

	// special values
	static constexpr time_point
	min() noexcept
	{ return time_point(duration::min()); }

	static constexpr time_point
	max() noexcept
	{ return time_point(duration::max()); }

      private:
	duration __d;
      };

    /// time_point_cast
    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
				   time_point<_Clock, _ToDur>>::type
      time_point_cast(const time_point<_Clock, _Dur>& __t)
      {
	typedef time_point<_Clock, _ToDur>			__time_point;
	return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
      }

#if __cplusplus > 201402L
    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      floor(const time_point<_Clock, _Dur>& __tp)
      {
	return time_point<_Clock, _ToDur>{
	    chrono::floor<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      ceil(const time_point<_Clock, _Dur>& __tp)
      {
	return time_point<_Clock, _ToDur>{
	    chrono::ceil<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr enable_if_t<
	__and_<__is_duration<_ToDur>,
	       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
	time_point<_Clock, _ToDur>>
      round(const time_point<_Clock, _Dur>& __tp)
      {
	return time_point<_Clock, _ToDur>{
	    chrono::round<_ToDur>(__tp.time_since_epoch())};
      }
#endif // C++17

    /// @relates time_point @{

    /// Adjust a time point forwards by the given duration.
    template<typename _Clock, typename _Dur1,
	     typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator+(const time_point<_Clock, _Dur1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<_Dur1,__dur2>::type	__ct;
	typedef time_point<_Clock, __ct>			__time_point;
	return __time_point(__lhs.time_since_epoch() + __rhs);
      }

    /// Adjust a time point forwards by the given duration.
    template<typename _Rep1, typename _Period1,
	     typename _Clock, typename _Dur2>
      constexpr time_point<_Clock,
	typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
      operator+(const duration<_Rep1, _Period1>& __lhs,
		const time_point<_Clock, _Dur2>& __rhs)
      {
	typedef duration<_Rep1, _Period1>			__dur1;
	typedef typename common_type<__dur1,_Dur2>::type	__ct;
	typedef time_point<_Clock, __ct>			__time_point;
	return __time_point(__rhs.time_since_epoch() + __lhs);
      }

    /// Adjust a time point backwards by the given duration.
    template<typename _Clock, typename _Dur1,
	     typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator-(const time_point<_Clock, _Dur1>& __lhs,
		const duration<_Rep2, _Period2>& __rhs)
      {
	typedef duration<_Rep2, _Period2>			__dur2;
	typedef typename common_type<_Dur1,__dur2>::type	__ct;
	typedef time_point<_Clock, __ct>			__time_point;
	return __time_point(__lhs.time_since_epoch() -__rhs);
      }

    /// @}

    /// @relates time_point @{

    /// The difference between two time points (as a duration)
    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr typename common_type<_Dur1, _Dur2>::type
      operator-(const time_point<_Clock, _Dur1>& __lhs,
		const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator==(const time_point<_Clock, _Dur1>& __lhs,
		 const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }

#if __cpp_lib_three_way_comparison
    template<typename _Clock, typename _Dur1,
	     three_way_comparable_with<_Dur1> _Dur2>
      constexpr auto
      operator<=>(const time_point<_Clock, _Dur1>& __lhs,
		  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() <=> __rhs.time_since_epoch(); }
#else
    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator!=(const time_point<_Clock, _Dur1>& __lhs,
		 const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs == __rhs); }
#endif

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<(const time_point<_Clock, _Dur1>& __lhs,
		const time_point<_Clock, _Dur2>& __rhs)
      { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<=(const time_point<_Clock, _Dur1>& __lhs,
		 const time_point<_Clock, _Dur2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>(const time_point<_Clock, _Dur1>& __lhs,
		const time_point<_Clock, _Dur2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>=(const time_point<_Clock, _Dur1>& __lhs,
		 const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs < __rhs); }

    // @}

    // Clocks.

    // Why nanosecond resolution as the default?
    // Why have std::system_clock always count in the highest
    // resolution (ie nanoseconds), even if on some OSes the low 3
    // or 9 decimal digits will be always zero? This allows later
    // implementations to change the system_clock::now()
    // implementation any time to provide better resolution without
    // changing function signature or units.

    // To support the (forward) evolution of the library's defined
    // clocks, wrap inside inline namespace so that the current
    // defintions of system_clock, steady_clock, and
    // high_resolution_clock types are uniquely mangled. This way, new
    // code can use the latests clocks, while the library can contain
    // compatibility definitions for previous versions.  At some
    // point, when these clocks settle down, the inlined namespaces
    // can be removed.  XXX GLIBCXX_ABI Deprecated
    inline namespace _V2 {

    /**
     *  @brief System clock.
     *
     *  Time returned represents wall time from the system-wide clock.
     *  @ingroup chrono
    */
    struct system_clock
    {
      typedef chrono::nanoseconds				duration;
      typedef duration::rep					rep;
      typedef duration::period					period;
      typedef chrono::time_point<system_clock, duration> 	time_point;

      static_assert(system_clock::duration::min()
		    < system_clock::duration::zero(),
		    "a clock's minimum duration cannot be less than its epoch");

      static constexpr bool is_steady = false;

      static time_point
      now() noexcept;

      // Map to C API
      static std::time_t
      to_time_t(const time_point& __t) noexcept
      {
	return std::time_t(duration_cast<chrono::seconds>
			   (__t.time_since_epoch()).count());
      }

      static time_point
      from_time_t(std::time_t __t) noexcept
      {
	typedef chrono::time_point<system_clock, seconds>	__from;
	return time_point_cast<system_clock::duration>
	       (__from(chrono::seconds(__t)));
      }
    };


    /**
     *  @brief Monotonic clock
     *
     *  Time returned has the property of only increasing at a uniform rate.
     *  @ingroup chrono
    */
    struct steady_clock
    {
      typedef chrono::nanoseconds				duration;
      typedef duration::rep					rep;
      typedef duration::period					period;
      typedef chrono::time_point<steady_clock, duration>	time_point;

      static constexpr bool is_steady = true;

      static time_point
      now() noexcept;
    };


    /**
     *  @brief Highest-resolution clock
     *
     *  This is the clock "with the shortest tick period." Alias to
     *  std::system_clock until higher-than-nanosecond definitions
     *  become feasible.
     *  @ingroup chrono
    */
    using high_resolution_clock = system_clock;

    } // end inline namespace _V2

#if __cplusplus > 201703L
    template<typename _Duration>
      using sys_time = time_point<system_clock, _Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days = sys_time<days>;

    using file_clock = ::std::filesystem::__file_clock;

    template<typename _Duration>
      using file_time = time_point<file_clock, _Duration>;

    template<> struct is_clock<system_clock> : true_type { };
    template<> struct is_clock<steady_clock> : true_type { };
    template<> struct is_clock<file_clock> : true_type { };

    template<> inline constexpr bool is_clock_v<system_clock> = true;
    template<> inline constexpr bool is_clock_v<steady_clock> = true;
    template<> inline constexpr bool is_clock_v<file_clock> = true;

    struct local_t { };
    template<typename _Duration>
      using local_time = time_point<local_t, _Duration>;
    using local_seconds = local_time<seconds>;
    using local_days = local_time<days>;

    class utc_clock;
    class tai_clock;
    class gps_clock;

    template<typename _Duration>
      using utc_time = time_point<utc_clock, _Duration>;
    using utc_seconds = utc_time<seconds>;

    template<typename _Duration>
      using tai_time = time_point<tai_clock, _Duration>;
    using tai_seconds = tai_time<seconds>;

    template<typename _Duration>
      using gps_time = time_point<gps_clock, _Duration>;
    using gps_seconds = gps_time<seconds>;

    template<> struct is_clock<utc_clock> : true_type { };
    template<> struct is_clock<tai_clock> : true_type { };
    template<> struct is_clock<gps_clock> : true_type { };

    template<> inline constexpr bool is_clock_v<utc_clock> = true;
    template<> inline constexpr bool is_clock_v<tai_clock> = true;
    template<> inline constexpr bool is_clock_v<gps_clock> = true;

    /**
     *  @brief Universal coordinated time clock
     *
     *  @ingroup chrono
    */
    class utc_clock
    {
    public:

      using duration = system_clock::duration;
      using rep = duration::rep;
      using period = duration::period;
      using time_point = chrono::time_point<utc_clock>;
      static constexpr bool is_steady = false;

      static time_point
      now()
      { return from_sys(system_clock::now()); }

      template<typename _Duration>
	static sys_time<common_type_t<_Duration, seconds>>
	to_sys(const chrono::time_point<utc_clock, _Duration>&);

      template<typename _Duration>
	static utc_time<common_type_t<_Duration, seconds>>
	from_sys(const chrono::time_point<system_clock, _Duration>&);
    };

    struct leap_second_info
    {
      bool    is_leap_scond;
      seconds elapsed;
    };

    template<typename _Duration>
      leap_second_info
      get_leap_second_info(const utc_time<_Duration>& __ut);

    /**
     *  @brief International Atomic Time (TAI) clock
     *
     *  @ingroup chrono
    */
    class tai_clock
    {
    public:

      using duration = system_clock::duration;
      using rep = duration::rep;
      using period = duration::period;
      using time_point = chrono::time_point<tai_clock>;
      static constexpr bool is_steady = false;

      static time_point
      now() noexcept(noexcept(utc_clock::now()))
      { return from_utc(utc_clock::now()); };

      template<typename _Duration>
	static utc_time<common_type_t<_Duration, seconds>>
	to_utc(const chrono::time_point<tai_clock, _Duration>& __t) noexcept
	{
	  using _Ct = common_type_t<_Duration, seconds>;
	  return utc_time<_Ct>{__t.time_since_epoch()} - 378691210s;
	}

      template<typename _Duration>
	static tai_time<common_type_t<_Duration, seconds>>
	from_utc(const chrono::time_point<utc_clock, _Duration>& __t) noexcept
	{
	  using _Ct = common_type_t<_Duration, seconds>;
	  return tai_time<_Ct>{__t.time_since_epoch()} + 378691210s;
	}
    };


    /**
     *  @brief Global Positioning System (GPS) clock
     *
     *  @ingroup chrono
    */
    class gps_clock
    {
    public:

      using duration = system_clock::duration;
      using rep = duration::rep;
      using period = duration::period;
      using time_point = chrono::time_point<gps_clock>;
      static constexpr bool is_steady = false;

      static time_point
      now() noexcept(noexcept(utc_clock::now()))
      { return from_utc(utc_clock::now()); }

      template<typename _Duration>
	static utc_time<common_type_t<_Duration, seconds>>
	to_utc(const chrono::time_point<gps_clock, _Duration>& __t) noexcept
	{
	  using _Ct = common_type_t<_Duration, seconds>;
	  return utc_time<_Ct>{__t.time_since_epoch()} - 315964809s;
	}

      template<typename _Duration>
	static gps_time<common_type_t<_Duration, seconds>>
	from_utc(const chrono::time_point<utc_clock, _Duration>& __t) noexcept
	{
	  using _Ct = common_type_t<_Duration, seconds>;
	  return gps_time<_Ct>{__t.time_since_epoch()} + 315964809s;
	}
    };

    // TIME_POINT CONVERSIONS

    template<typename _DestClock, typename _SourceClock>
      struct clock_time_conversion;

    //template<typename _DestClock, typename _SourceClock, typename _Duration>
    //  time_point<_DestClock, see below>
    //  clock_cast(const time_point<_SourceClock, _Duration>& __t);

    // Identity
    template<typename _Clock>
      struct clock_time_conversion<_Clock, _Clock>
      {
        template<typename _Duration>
	  time_point<_Clock, _Duration>
	  operator()(const time_point<_Clock, _Duration>& __t) const
	  { return __t; }
      };

    template<>
      struct clock_time_conversion<system_clock, system_clock>
      {
        template<typename _Duration>
	  sys_time<_Duration>
	  operator()(const sys_time<_Duration>& __t) const
	  { return __t; }
      };

    template<>
      struct clock_time_conversion<utc_clock, utc_clock>
      {
        template<typename _Duration>
	  utc_time<_Duration>
	  operator()(const utc_time<_Duration>& __t) const
	  { return __t; }
      };

    // system_clock <-> utc_clock
    template<>
      struct clock_time_conversion<utc_clock, system_clock>
      {
        template<typename _Duration>
	  utc_time<common_type_t<_Duration, seconds>>
	  operator()(const sys_time<_Duration>& __t) const
	  { return utc_clock::from_sys(__t); }
      };

    template<>
      struct clock_time_conversion<system_clock, utc_clock>
      {
        template<typename _Duration>
	  sys_time<common_type_t<_Duration, seconds>>
	  operator()(const utc_time<_Duration>& __t) const
	  { return utc_clock::to_sys(__t); }
      };

    // Clock <-> system_clock
    template<typename _SourceClock>
      struct clock_time_conversion<system_clock, _SourceClock>
      {
        template<typename _Duration>
	  auto
	  operator()(const time_point<_SourceClock, _Duration>& __t) const
	  -> decltype(_SourceClock::to_sys(__t))
	  { return _SourceClock::to_sys(__t); }
      };


    template<typename _DestClock>
      struct clock_time_conversion<_DestClock, system_clock>
      {
        template<typename _Duration>
	  auto
	  operator()(const sys_time<_Duration>& __t) const
	  -> decltype(_DestClock::from_sys(__t))
	  { return _DestClock::from_sys(__t); }
      };

    // Clock <-> utc_clock
    template<typename _SourceClock>
      struct clock_time_conversion<utc_clock, _SourceClock>
      {
        template<typename _Duration>
	  auto
	  operator()(const time_point<_SourceClock, _Duration>& __t) const
	  -> decltype(_SourceClock::to_utc(__t))
	  { return _SourceClock::to_utc(__t); }
     };

    template<typename _DestClock>
      struct clock_time_conversion<_DestClock, utc_clock>
      {
        template<typename _Duration>
	  auto
	  operator()(const utc_time<_Duration>& __t) const
	  -> decltype(_DestClock::from_utc(__t))
	  { return _DestClock::from_utc(__t); }
      };

    // CALENDRICAL TYPES

    struct last_spec;

    // DAY

    class day
    {
    private:

      unsigned char _M_d;

    public:

      day() = default;

      explicit constexpr day(unsigned __d) noexcept
      : _M_d(__d)
      { }

      constexpr day&
      operator++() noexcept
      {
        ++this->_M_d;
        return *this;
      }

      constexpr day
      operator++(int) noexcept
      {
        auto ret(*this);
        ++this->_M_d;
        return ret;
      }

      constexpr day&
      operator--() noexcept
      {
        --this->_M_d;
        return *this;
      }

      constexpr day
      operator--(int) noexcept
      {
        auto ret(*this);
        --this->_M_d;
        return ret;
      }

      constexpr day&
      operator+=(const days& __d) noexcept
      {
        this->_M_d += __d.count();
        return *this;
      }

      constexpr day&
      operator-=(const days& __d) noexcept
      {
        this->_M_d -= __d.count();
        return *this;
      }

      constexpr explicit
      operator unsigned() const noexcept
      { return this->_M_d; }

      constexpr bool
      ok() const noexcept
      { return 1 <= this->_M_d && this->_M_d <= 31; }
    };

    constexpr bool
    operator==(const day& __x, const day& __y) noexcept
    { return unsigned{__x} == unsigned{__y}; }

    constexpr bool
    operator!=(const day& __x, const day& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const day& __x, const day& __y) noexcept
    { return unsigned{__x} < unsigned{__y}; }

    constexpr bool
    operator>(const day& __x, const day& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const day& __x, const day& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const day& __x, const day& __y) noexcept
    { return !(__x < __y); }

    constexpr day
    operator+(const day& __x, const days& __y) noexcept
    { return day(unsigned{__x} + __y.count()); }

    constexpr day
    operator+(const days& __x, const day& __y) noexcept
    { return __y + __x; }

    constexpr day
    operator-(const day& __x, const days& __y) noexcept
    { return __x + -__y; }

    constexpr days
    operator-(const day& __x, const day& __y) noexcept
    { return days{int(unsigned{__x}) - int(unsigned{__y})}; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os, const day& __d);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const day& __d);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  day& __d,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // MONTH

    class month
    {
    private:

      unsigned char _M_m;

    public:

      month() = default;

      explicit constexpr
      month(unsigned __m) noexcept
      : _M_m(__m)
      { }

      constexpr month&
      operator++() noexcept
      {
        ++this->_M_m;
        return *this;
      }

      constexpr month
      operator++(int) noexcept
      {
        auto ret(*this);
        ++this->_M_m;
        return ret;
      }

      constexpr month&
      operator--() noexcept
      {
        --this->_M_m;
        return *this;
      }

      constexpr month
      operator--(int) noexcept
      {
        auto ret(*this);
        --this->_M_m;
        return ret;
      }

      constexpr month&
      operator+=(const months& __m) noexcept
      {
        this->_M_m += __m.count();
        return *this;
      }

      constexpr month&
      operator-=(const months& __m) noexcept
      {
        this->_M_m -= __m.count();
        return *this;
      }

      explicit constexpr
      operator unsigned() const noexcept
      { return this->_M_m; }

      constexpr bool
      ok() const noexcept
      { return 1 <= this->_M_m && this->_M_m <= 12; }
    };

    inline constexpr chrono::month January{1};
    inline constexpr chrono::month February{2};
    inline constexpr chrono::month March{3};
    inline constexpr chrono::month April{4};
    inline constexpr chrono::month May{5};
    inline constexpr chrono::month June{6};
    inline constexpr chrono::month July{7};
    inline constexpr chrono::month August{8};
    inline constexpr chrono::month September{9};
    inline constexpr chrono::month October{10};
    inline constexpr chrono::month November{11};
    inline constexpr chrono::month December{12};

    constexpr bool
    operator==(const month& __x, const month& __y) noexcept
    { return unsigned{__x} == unsigned{__y}; }

    constexpr bool
    operator!=(const month& __x, const month& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const month& __x, const month& __y) noexcept
    { return unsigned{__x} < unsigned{__y}; }

    constexpr bool
    operator>(const month& __x, const month& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const month& __x, const month& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const month& __x, const month& __y) noexcept
    { return !(__x < __y); }

    constexpr month
    operator+(const month& __x, const months& __y) noexcept
    { return month(__detail::__modulo<unsigned char>(
			  static_cast<long long>(unsigned{__x})
	 	  + (__y.count() - 1), 12) + 1); }

    constexpr month
    operator+(const months& __x,  const month& __y) noexcept
    { return __y + __x; }

    constexpr month
    operator-(const month& __x, const months& __y) noexcept
    { return __x + -__y; }

    constexpr months
    operator-(const month& __x,  const month& __y) noexcept
    {
      const auto __dm = int(unsigned(__x)) - int(unsigned(__y));
      return months{__dm < 0 ? 12 + __dm : __dm};
    }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os, const month& __m);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const month& __m);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  month& __m,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // YEAR

    class year
    {
      short _M_y;

    public:

      year() = default;

      explicit constexpr
      year(int __y) noexcept
      : _M_y{static_cast<short>(__y)}
      { }

      static constexpr year
      min() noexcept
      { return year{-32767}; }

      static constexpr year
      max() noexcept
      { return year{32767}; }

      constexpr year&
      operator++() noexcept
      {
        ++this->_M_y;
        return *this;
      }

      constexpr year
      operator++(int) noexcept
      {
        auto ret(*this);
        ++this->_M_y;
        return ret;
      }

      constexpr year&
      operator--() noexcept
      {
        --this->_M_y;
        return *this;
      }

      constexpr year
      operator--(int) noexcept
      {
        auto ret(*this);
        --this->_M_y;
        return ret;
      }

      constexpr year&
      operator+=(const years& __y) noexcept
      {
        this->_M_y += __y.count();
        return *this;
      }

      constexpr year&
      operator-=(const years& __y) noexcept
      {
        this->_M_y -= __y.count();
        return *this;
      }

      constexpr year
      operator+() const noexcept
      { return *this; }

      constexpr year
      operator-() const noexcept
      { return year(-this->_M_y); }

      constexpr bool
      is_leap() const noexcept
      {
        return this->_M_y % 4 == 0
	    && (this->_M_y % 100 != 0 || this->_M_y % 400 == 0);
      }

      explicit constexpr
      operator int() const noexcept
      { return this->_M_y; }

      constexpr bool
      ok() const noexcept
      { return int(year::min()) <= this->_M_y && this->_M_y <= int(year::max()); }
    };

    constexpr bool
    operator==(const year& __x, const year& __y) noexcept
    { return int{__x} == int{__y}; }

    constexpr bool
    operator!=(const year& __x, const year& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const year& __x, const year& __y) noexcept
    { return int{__x} < int{__y}; }

    constexpr bool
    operator>(const year& __x, const year& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const year& __x, const year& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const year& __x, const year& __y) noexcept
    { return !(__x < __y); }

    constexpr year
    operator+(const year& __x, const years& __y) noexcept
    { return year{static_cast<int>(__x) + __y.count()}; }

    constexpr year
    operator+(const years& __x, const year& __y) noexcept
    { return __y + __x; }

    constexpr year
    operator-(const year& __x, const years& __y) noexcept
    { return year{static_cast<int>(__x) - __y.count()}; }

    constexpr years
    operator-(const year& __x, const year& __y) noexcept
    { return years{static_cast<int>(__x) - static_cast<int>(__y)}; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os, const year& __y);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const year& __y);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  year& __y,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // WEEKDAY

    class weekday
    {
    private:

      unsigned char _M_wd;

      constexpr static unsigned char
      _S_from_days(int __d) noexcept
      {
        return static_cast<unsigned char>(
          unsigned(__d >= -4 ? (__d + 4) % 7 : (__d + 5) % 7 + 6));
      }

    public:

      weekday() = default;

      explicit constexpr
      weekday(unsigned __wd) noexcept
      : _M_wd(__wd == 7 ? 0 : __wd) // __wd % 7 ?
      { }

      constexpr
      weekday(const sys_days& __dp) noexcept
      : _M_wd(weekday::_S_from_days(__dp.time_since_epoch().count()))
      { }

      explicit constexpr
      weekday(const local_days& __dp) noexcept
      : _M_wd(weekday::_S_from_days(__dp.time_since_epoch().count()))
      { }

      constexpr weekday&
      operator++() noexcept
      {
        ++this->_M_wd;
        return *this;
      }

      constexpr weekday
      operator++(int) noexcept
      {
        auto __ret(*this);
        ++(*this);
        return __ret;
      }

      constexpr weekday&
      operator--() noexcept
      {
        --this->_M_wd;
        return *this;
      }

      constexpr weekday
      operator--(int) noexcept
      {
        auto __ret(*this);
        --(*this);
        return __ret;
      }

      constexpr weekday&
      operator+=(const days& __d) noexcept
      {
        *this = *this + __d;
        return *this;
      }

      constexpr weekday&
      operator-=(const days& __d) noexcept
      {
        *this = *this - __d;
        return *this;
      }

      explicit constexpr
      operator unsigned() const noexcept
      { return this->_M_wd; }

      constexpr bool
      ok() const noexcept
      { return this->_M_wd <= 6; }

      constexpr weekday_indexed
      operator[](unsigned __index) const noexcept;

      constexpr weekday_last
      operator[](last_spec) const noexcept;
    };

    inline constexpr chrono::weekday Sunday{0};
    inline constexpr chrono::weekday Monday{1};
    inline constexpr chrono::weekday Tuesday{2};
    inline constexpr chrono::weekday Wednesday{3};
    inline constexpr chrono::weekday Thursday{4};
    inline constexpr chrono::weekday Friday{5};
    inline constexpr chrono::weekday Saturday{6};

    constexpr bool
    operator==(const weekday& __x, const weekday& __y) noexcept
    { return unsigned{__x} == unsigned{__y}; }

    constexpr bool
    operator!=(const weekday& __x, const weekday& __y) noexcept
    { return !(__x == __y); }

    constexpr weekday
    operator+(const weekday& __x, const days& __y) noexcept
    { return weekday(__detail::__modulo<unsigned char>(
			  static_cast<long long>(unsigned{__x})
			  + __y.count(), 7)); }

    constexpr weekday
    operator+(const days& __x, const weekday& __y) noexcept
    { return __y + __x; }

    constexpr weekday
    operator-(const weekday& __x, const days& __y) noexcept
    { return __x + -__y; }

    constexpr days
    operator-(const weekday& __x, const weekday& __y) noexcept
    {
      const auto __dwd = int(unsigned(__x)) - int(unsigned(__y));
      const auto __w = (__dwd >= 0 ? __dwd : __dwd - 6) / 7;
      return days{__dwd - __w * 7};
    }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os, const weekday& __wd);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os, const _CharT* __fmt,
	        const weekday& __wd);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  weekday& __wd,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // WEEKDAY_INDEXED

    class weekday_indexed
    {
    private:

      chrono::weekday _M_wd;
      unsigned char _M_index;

    public:

      weekday_indexed() = default;

      constexpr
      weekday_indexed(const chrono::weekday& __wd, unsigned __index) noexcept
      : _M_wd(__wd), _M_index(__index)
      { }

      constexpr chrono::weekday
      weekday() const noexcept
      { return this->_M_wd; }

      constexpr unsigned
      index() const noexcept
      { return this->_M_index; };

      constexpr bool
      ok() const noexcept
      { return _M_wd.ok() && 1 <= this->_M_index && this->_M_index <= 5; }
    };

    constexpr bool
    operator==(const weekday_indexed& __x, const weekday_indexed& __y) noexcept
    { return __x.weekday() == __y.weekday() && __x.index() == __y.index(); }

    constexpr bool
    operator!=(const weekday_indexed& __x, const weekday_indexed& __y) noexcept
    { return !(__x == __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const weekday_indexed& __wdi);
*/
    inline constexpr weekday_indexed
    weekday::operator[](unsigned __index) const noexcept
    { return {*this, __index}; }

    // WEEKDAY_LAST

    class weekday_last
    {
    private:

      chrono::weekday _M_wd;

    public:

      explicit constexpr
      weekday_last(const chrono::weekday& __wd) noexcept
      : _M_wd{__wd}
      { }

      constexpr chrono::weekday
      weekday() const noexcept
      { return this->_M_wd; }

      constexpr bool
      ok() const noexcept
      { return this->_M_wd.ok(); }
    };

    constexpr bool
    operator==(const weekday_last& __x, const weekday_last& __y) noexcept
    { return __x.weekday() == __y.weekday(); }

    constexpr bool
    operator!=(const weekday_last& __x, const weekday_last& __y) noexcept
    { return !(__x == __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const weekday_last& __wdl);
*/
    inline constexpr weekday_last
    weekday::operator[](last_spec) const noexcept
    { return weekday_last{*this}; }

    // MONTH_DAY

    class month_day
    {
      chrono::month _M_m;
      chrono::day _M_d;

    public:

      month_day() = default;

      constexpr
      month_day(const chrono::month& __m, const chrono::day& __d) noexcept
      : _M_m{__m}, _M_d{__d}
      { }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::day
      day() const noexcept
      { return this->_M_d; }

      constexpr bool
      ok() const noexcept
      {
        return 1u <= unsigned(this->_M_d)
	  && this->_M_m.ok()
	  && unsigned(this->_M_d)
	     <= __detail::__days_per_month[unsigned(this->_M_m) - 1];
      }
    };

    constexpr bool
    operator==(const month_day& __x, const month_day& __y) noexcept
    { return __x.month() == __y.month() && __x.day() == __y.day(); }

    constexpr bool
    operator!=(const month_day& __x, const month_day& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const month_day& __x, const month_day& __y) noexcept
    {
      if (__x.month() < __y.month())
        return true;
      else if (__x.month() > __y.month())
        return false;
      else
        return __x.day() < __y.day();
    }

    constexpr bool
    operator>(const month_day& __x, const month_day& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const month_day& __x, const month_day& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const month_day& __x, const month_day& __y) noexcept
    { return !(__x < __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os, const month_day& __md);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const month_day& __md);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  month_day& __md,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // MONTH_DAY_LAST

    class month_day_last
    {
    private:

      chrono::month _M_m;

    public:

      explicit constexpr
      month_day_last(const chrono::month& __m) noexcept
      : _M_m{__m}
      { }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr bool
      ok() const noexcept
      { return this->_M_m.ok(); }
    };

    constexpr bool
    operator==(const month_day_last& __x, const month_day_last& __y) noexcept
    { return __x.month() == __y.month(); }

    constexpr bool
    operator!=(const month_day_last& __x, const month_day_last& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const month_day_last& __x, const month_day_last& __y) noexcept
    { return __x.month() < __y.month(); }

    constexpr bool
    operator>(const month_day_last& __x, const month_day_last& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const month_day_last& __x, const month_day_last& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const month_day_last& __x, const month_day_last& __y) noexcept
    { return !(__x < __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const month_day_last& __mdl);
*/
    // MONTH_WEEKDAY

    class month_weekday
    {
    private:

      chrono::month _M_m;
      chrono::weekday_indexed _M_wdi;

    public:

      constexpr
      month_weekday(const chrono::month& __m,
		    const chrono::weekday_indexed& __wdi) noexcept
      : _M_m{__m}, _M_wdi{__wdi}
      { }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::weekday_indexed
      weekday_indexed() const noexcept
      { return this->_M_wdi; }

      constexpr bool
      ok() const noexcept
      { return this->_M_m.ok() && this->_M_wdi.ok(); }
    };

    constexpr bool
    operator==(const month_weekday& __x, const month_weekday& __y) noexcept
    {
      return __x.month() == __y.month()
	  && __x.weekday_indexed() == __y.weekday_indexed();
    }

    constexpr bool
    operator!=(const month_weekday& __x, const month_weekday& __y) noexcept
    { return !(__x == __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const month_weekday& __mwd);
*/
    // MONTH_WEEKDAY_LAST

    class month_weekday_last
    {
    private:

      chrono::month _M_m;
      chrono::weekday_last _M_wdl;

    public:

      constexpr
      month_weekday_last(const chrono::month& __m,
                         const chrono::weekday_last& __wdl) noexcept
      :_M_m{__m}, _M_wdl{__wdl}
      { }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::weekday_last
      weekday_last() const noexcept
      { return this->_M_wdl; }

      constexpr bool
      ok() const noexcept
      { return this->_M_m.ok() && this->_M_wdl.ok(); }
    };

    constexpr bool
    operator==(const month_weekday_last& __x,
	       const month_weekday_last& __y) noexcept
    {
      return __x.month() == __y.month()
	  && __x.weekday_last() == __y.weekday_last();
    }

    constexpr bool
    operator!=(const month_weekday_last& __x,
	       const month_weekday_last& __y) noexcept
    { return !(__x == __y); }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const month_weekday_last& __mwdl);
*/
    // YEAR_MONTH

    class year_month
    {
    private:

      chrono::year _M_y;
      chrono::month _M_m;

    public:

      year_month() = default;

      constexpr
      year_month(const chrono::year& __y, const chrono::month& __m) noexcept
      : _M_y{__y}, _M_m{__m}
      { }

      constexpr chrono::year
      year() const noexcept
      { return this->_M_y; }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr year_month&
      operator+=(const months& __dm) noexcept
      {
        // Does this work for negative dm?
        this->_M_y += years{__dm.count() / 12};
        this->_M_m += months{__dm.count() % 12};
        return *this;
      }

      constexpr year_month&
      operator-=(const months& __dm) noexcept
      {
        this->operator+=(-__dm);
        return *this;
      }

      constexpr year_month&
      operator+=(const years& __dy)  noexcept
      {
        this->_M_y += __dy;
        return *this;
      }

      constexpr year_month&
      operator-=(const years& __dy)  noexcept
      {
        this->_M_y -= __dy;
        return *this;
      }

      constexpr bool
      ok() const noexcept
      { return this->_M_y.ok() && this->_M_m.ok(); }
    };

    constexpr bool
    operator==(const year_month& __x, const year_month& __y) noexcept
    { return __x.year() == __y.year() && __x.month() == __y.month(); }

    constexpr bool
    operator!=(const year_month& __x, const year_month& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const year_month& __x, const year_month& __y) noexcept
    {
      if (__x.year() < __y.year())
        return true;
      else if (__x.year() > __y.year())
        return false;
      else
        return __x.month() < __y.month();
    }

    constexpr bool
    operator>(const year_month& __x, const year_month& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const year_month& __x, const year_month& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const year_month& __x, const year_month& __y) noexcept
    { return !(__x < __y); }

    constexpr year_month
    operator+(const year_month& __ym, const months& __dm) noexcept
    {
      auto __ret = __ym;
      return __ret += __dm;
    }

    constexpr year_month
    operator+(const months& __dm, const year_month& __ym) noexcept
    { return __ym + __dm; }

    constexpr year_month
    operator-(const year_month& __ym, const months& __dm) noexcept
    { return __ym + -__dm; }

    constexpr months
    operator-(const year_month& __x, const year_month& __y) noexcept
    {
      return __x.year() - __y.year()
	   + months{static_cast<int>(unsigned{__x.month()})
		  - static_cast<int>(unsigned{__y.month()})};
    }

    constexpr year_month
    operator+(const year_month& __ym, const years& __dy) noexcept
    { return (__ym.year() + __dy) / __ym.month(); }

    constexpr year_month
    operator+(const years& __dy, const year_month& __ym) noexcept
    { return __ym + __dy; }

    constexpr year_month
    operator-(const year_month& __ym, const years& __dy) noexcept
    { return __ym + -__dy; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const year_month& __ym);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const year_month& __ym);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  year_month& __ym,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // YEAR_MONTH_DAY

    class year_month_day
    {
    private:

      chrono::year _M_y;
      chrono::month _M_m;
      chrono::day _M_d;

      static constexpr year_month_day _S_from_days(const days& __dp) noexcept;

      constexpr days _M_days_since_epoch() const noexcept;

    public:

      year_month_day() = default;

      constexpr
      year_month_day(const chrono::year& __y, const chrono::month& __m,
		     const chrono::day& __d) noexcept
      : _M_y{__y}, _M_m{__m}, _M_d{__d}
      { }

      constexpr
      year_month_day(const year_month_day_last& __ymdl) noexcept;

      constexpr
      year_month_day(const sys_days& __dp) noexcept
      : year_month_day(year_month_day::_S_from_days(__dp.time_since_epoch()))
      { }

      explicit constexpr
      year_month_day(const local_days& __dp) noexcept
      : year_month_day(year_month_day::_S_from_days(__dp.time_since_epoch()))
      { }

      constexpr year_month_day&
      operator+=(const months& __m) noexcept
      {
        chrono::year_month __ym(this->year(), this->month());
        __ym += __m;
        this->_M_y = __ym.year();
        this->_M_m = __ym.month();
        return *this;
      }

      constexpr year_month_day&
      operator-=(const months& __m) noexcept
      {
        chrono::year_month __ym(this->year(), this->month());
        __ym -= __m;
        this->_M_y = __ym.year();
        this->_M_m = __ym.month();
        return *this;
      }

      constexpr year_month_day&
      operator+=(const years& __y) noexcept
      {
        this->_M_y += __y;
        return *this;
      }

      constexpr year_month_day&
      operator-=(const years& __y) noexcept
      {
        this->_M_y -= __y;
        return *this;
      }

      constexpr chrono::year
      year() const noexcept
      { return this->_M_y; }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::day
      day() const noexcept
      { return this->_M_d; }

      constexpr
      operator sys_days() const noexcept
      { return sys_days{this->_M_days_since_epoch()}; }

      explicit constexpr
      operator local_days() const noexcept
      { return local_days{this->_M_days_since_epoch()}; }

      constexpr bool
      ok() const noexcept
      {
        return this->_M_y.ok() && this->_M_m.ok() && this->_M_d.ok()
	    && unsigned(this->_M_d)
		  <= __detail::__days_per_month[unsigned(this->_M_m) - 1];
      }
    };

    // Construct from days since 1970/01/01. Magic.
    inline constexpr year_month_day
    year_month_day::_S_from_days(const days& __dp) noexcept
    {
      const auto __z = __dp.count() + 719468;
      const auto __era = (__z >= 0 ? __z : __z - 146096) / 146097;
      const auto __doe = static_cast<unsigned>(__z - __era * 146097);
      const auto __yoe = (__doe - __doe / 1460 + __doe / 36524 - __doe / 146096)
		        / 365;
      const auto __y = static_cast<days::rep>(__yoe) + __era * 400;
      const auto __doy = __doe - (365 * __yoe + __yoe / 4 - __yoe / 100);
      const auto __mp = (5 * __doy + 2) / 153;
      const auto __d = __doy - (153 * __mp + 2) / 5 + 1;
      const auto __m = __mp < 10 ? __mp + 3 : __mp - 9;
      return year_month_day{chrono::year(__y + (__m <= 2)),
			    chrono::month(__m), chrono::day(__d)};
    }

    // Days since 1970/01/01. Magic.
    inline constexpr days
    year_month_day::_M_days_since_epoch() const noexcept
    {
      const auto __y = static_cast<int>(this->_M_y) - (this->_M_m <= February);
      const auto __m = static_cast<unsigned>(this->_M_m);
      const auto __d = static_cast<unsigned>(this->_M_d);
      const auto __era = (__y >= 0 ? __y : __y - 399) / 400;
      // Year of "era" [0, 399].
      const auto __yoe = static_cast<unsigned>(__y - __era * 400);
      // Day of year [0, 365].
      const auto __doy = (153 * (__m > 2 ? __m - 3 : __m + 9) + 2) / 5 + __d - 1;
      // Day of "era" [0, 146096].
      const auto __doe = __yoe * 365 + __yoe / 4 - __yoe / 100 + __doy;
      const auto __days = __era * 146097 + static_cast<int>(__doe) - 719468;
      return days{__days};
    }

    constexpr bool
    operator==(const year_month_day& __x, const year_month_day& __y) noexcept
    {
      return __x.year() == __y.year()
	  && __x.month() == __y.month()
	  && __x.day() == __y.day();
    }

    constexpr bool
    operator!=(const year_month_day& __x, const year_month_day& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const year_month_day& __x, const year_month_day& __y) noexcept
    {
      if (__x.year() < __y.year())
        return true;
      else if (__x.year() > __y.year())
        return false;
      else
        {
	  if (__x.month() < __y.month())
	    return true;
	  else if (__x.month() > __y.month())
	    return false;
	  else
	    return __x.day() < __y.day();
        }
    }

    constexpr bool
    operator>(const year_month_day& __x, const year_month_day& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const year_month_day& __x, const year_month_day& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const year_month_day& __x, const year_month_day& __y) noexcept
    { return !(__x < __y); }

    constexpr year_month_day
    operator+(const year_month_day& __ymd, const months& __dm) noexcept
    { return (__ymd.year() / __ymd.month() + __dm) / __ymd.day(); }

    constexpr year_month_day
    operator+(const months& __dm, const year_month_day& __ymd) noexcept
    { return __ymd + __dm; }

    constexpr year_month_day
    operator+(const year_month_day& __ymd, const years& __dy) noexcept
    { return (__ymd.year() + __dy) / __ymd.month() / __ymd.day(); }

    constexpr year_month_day
    operator+(const years& __dy, const year_month_day& __ymd) noexcept
    { return __ymd + __dy; }

    constexpr year_month_day
    operator-(const year_month_day& __ymd, const months& __dm) noexcept
    { return __ymd + -__dm; }

    constexpr year_month_day
    operator-(const year_month_day& __ymd, const years& __dy) noexcept
    { return __ymd + -__dy; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const year_month_day& __ymd);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      to_stream(std::basic_ostream<_CharT, _Traits>& __os,
	        const _CharT* __fmt, const year_month_day& __ymd);

    template<typename _CharT, typename _Traits,
	     typename _Alloc = allocator<_CharT>>
      std::basic_istream<_CharT, _Traits>&
      from_stream(std::basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,
		  year_month_day& __ymd,
		  std::basic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,
		  minutes* __offset = nullptr);
*/
    // YEAR_MONTH_DAY_LAST

    class year_month_day_last
    {
    private:

      chrono::year _M_y;
      chrono::month_day_last _M_mdl;

    public:

      constexpr
      year_month_day_last(const chrono::year& __y,
                          const chrono::month_day_last& __mdl) noexcept
      : _M_y{__y}, _M_mdl{__mdl}
      { }

      constexpr year_month_day_last&
      operator+=(const months& __m) noexcept
      {
        *this = *this + __m;
        return *this;
      }

      constexpr year_month_day_last&
      operator-=(const months& __m) noexcept
      {
        *this = *this - __m;
        return *this;
      }

      constexpr year_month_day_last&
      operator+=(const years& __y)  noexcept
      {
        *this = *this + __y;
        return *this;
      }

      constexpr year_month_day_last&
      operator-=(const years& __y)  noexcept
      {
        *this = *this - __y;
        return *this;
      }

      constexpr chrono::year
      year() const noexcept
      { return this->_M_y; }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_mdl.month(); }

      constexpr chrono::month_day_last
      month_day_last() const noexcept
      { return this->_M_mdl; }

      // Return A day representing the last day of this year, month pair.
      constexpr chrono::day
      day() const noexcept
      {
        return this->month() != chrono::month{2}
	  || !this->_M_y.is_leap()
	   ? chrono::day{__detail::__last_day[unsigned(this->_M_mdl.month()) - 1]}
	   : chrono::day{29};
      }

      constexpr
      operator sys_days() const noexcept
      { return sys_days{this->year() / this->month() / this->day()}; }

      explicit constexpr
      operator local_days() const noexcept
      { return local_days{sys_days{*this}.time_since_epoch()}; }

      constexpr bool
      ok() const noexcept
      { return this->_M_y.ok() && this->_M_mdl.ok(); }
    };

    // year_month_day ctor from year_month_day_last
    inline constexpr
    year_month_day::year_month_day(const year_month_day_last& __ymdl) noexcept
    : _M_y{__ymdl.year()}, _M_m{__ymdl.month()}, _M_d{__ymdl.day()}
    { }

    constexpr bool
    operator==(const year_month_day_last& __x,
	       const year_month_day_last& __y) noexcept
    {
      return __x.year() == __y.year()
	  && __x.month_day_last() == __y.month_day_last();
    }

    constexpr bool
    operator!=(const year_month_day_last& __x,
	       const year_month_day_last& __y) noexcept
    { return !(__x == __y); }

    constexpr bool
    operator<(const year_month_day_last& __x,
	      const year_month_day_last& __y) noexcept
    {
      if (__x.year() < __y.year())
        return true;
      else if (__x.year() > __y.year())
        return false;
      else
        return __x.month_day_last() < __y.month_day_last();
    }

    constexpr bool
    operator>(const year_month_day_last& __x,
	      const year_month_day_last& __y) noexcept
    { return __y < __x; }

    constexpr bool
    operator<=(const year_month_day_last& __x,
	       const year_month_day_last& __y) noexcept
    { return !(__y < __x); }

    constexpr bool
    operator>=(const year_month_day_last& __x,
	       const year_month_day_last& __y) noexcept
    { return !(__x < __y); }

    constexpr year_month_day_last
    operator+(const year_month_day_last& __ymdl,
	      const months& __dm) noexcept
    { return (__ymdl.year() / __ymdl.month() + __dm) / last; }

    constexpr year_month_day_last
    operator+(const months& __dm,
	      const year_month_day_last& __ymdl) noexcept
    { return __ymdl + __dm; }

    constexpr year_month_day_last
    operator-(const year_month_day_last& __ymdl,
	      const months& __dm) noexcept
    { return __ymdl + -__dm; }

    constexpr year_month_day_last
    operator+(const year_month_day_last& __ymdl,
	      const years& __dy) noexcept
    { return {__ymdl.year() + __dy, __ymdl.month_day_last()}; }

    constexpr year_month_day_last
    operator+(const years& __dy,
	      const year_month_day_last& __ymdl) noexcept
    { return __ymdl + __dy; }

    constexpr year_month_day_last
    operator-(const year_month_day_last& __ymdl,
	      const years& __dy) noexcept
    { return __ymdl + -__dy; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const year_month_day_last& __ymdl);
*/
    // YEAR_MONTH_WEEKDAY

    class year_month_weekday
    {
    private:

      chrono::year            _M_y;
      chrono::month           _M_m;
      chrono::weekday_indexed _M_wdi;

    public:

      year_month_weekday() = default;

      constexpr
      year_month_weekday(const chrono::year& __y, const chrono::month& __m,
                         const chrono::weekday_indexed& __wdi) noexcept
      : _M_y{__y}, _M_m{__m}, _M_wdi{__wdi}
      { }

      constexpr
      year_month_weekday(const sys_days& __dp) noexcept;

      explicit constexpr
      year_month_weekday(const local_days& __dp) noexcept;

      constexpr year_month_weekday&
      operator+=(const months& __m) noexcept;

      constexpr year_month_weekday&
      operator-=(const months& __m) noexcept;

      constexpr year_month_weekday&
      operator+=(const years& __y) noexcept;

      constexpr year_month_weekday&
      operator-=(const years& y) noexcept;

      constexpr chrono::year
      year() const noexcept
      { return this->_M_y; }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::weekday
      weekday() const noexcept
      { return this->_M_wdi.weekday(); }

      constexpr unsigned
      index() const noexcept
      { return this->_M_wdi.index(); }

      constexpr chrono::weekday_indexed
      weekday_indexed() const noexcept
      { return this->_M_wdi; }

      constexpr
      operator sys_days() const noexcept;

      explicit constexpr
      operator local_days() const noexcept
      { local_days{sys_days{*this}.time_since_epoch()}; }

      constexpr bool
      ok() const noexcept
      { return this->_M_y.ok() && this->_M_m.ok() && this->_M_wdi.ok(); }
    };

    constexpr bool
    operator==(const year_month_weekday& __x,
	       const year_month_weekday& __y) noexcept
    {
      return __x.year() == __y.year()
	  && __x.month() == __y.month()
	  && __x.weekday() == __y.weekday();
    }

    constexpr bool
    operator!=(const year_month_weekday& __x,
	       const year_month_weekday& __y) noexcept
    { return !(__x == __y); }

    constexpr year_month_weekday
    operator+(const year_month_weekday& __ymwd, const months& __dm) noexcept
    { return (__ymwd.year() / __ymwd.month() + __dm) / __ymwd.weekday_indexed(); }

    constexpr year_month_weekday
    operator+(const months& __dm, const year_month_weekday& __ymwd) noexcept
    { return __ymwd + __dm; }

    constexpr year_month_weekday
    operator+(const year_month_weekday& __ymwd, const years& __dy) noexcept
    { return {__ymwd.year() + __dy, __ymwd.month(), __ymwd.weekday_indexed()}; }

    constexpr year_month_weekday
    operator+(const years& __dy, const year_month_weekday& __ymwd) noexcept
    { return __ymwd + __dy; }

    constexpr year_month_weekday
    operator-(const year_month_weekday& __ymwd, const months& __dm) noexcept
    { return __ymwd + -__dm; }

    constexpr year_month_weekday
    operator-(const year_month_weekday& __ymwd, const years& __dy) noexcept
    { return __ymwd + -__dy; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const year_month_weekday& __ymwdi);
*/
    // YEAR_MONTH_WEEKDAY_LAST

    class year_month_weekday_last
    {
    private:

      chrono::year _M_y;
      chrono::month _M_m;
      chrono::weekday_last _M_wdl;

    public:

      constexpr
      year_month_weekday_last(const chrono::year& __y, const chrono::month& __m,
                              const chrono::weekday_last& __wdl) noexcept
      : _M_y{__y}, _M_m{__m}, _M_wdl{__wdl}
      { }

      constexpr year_month_weekday_last&
      operator+=(const months& __m) noexcept
      {
        *this = *this + __m;
        return *this;
      }

      constexpr year_month_weekday_last&
      operator-=(const months& __m) noexcept
      {
        *this = *this - __m;
        return *this;
      }

      constexpr year_month_weekday_last&
      operator+=(const years& __y)  noexcept
      {
        *this = *this + __y;
        return *this;
      }

      constexpr year_month_weekday_last&
      operator-=(const years& __y)  noexcept
      {
        *this = *this - __y;
        return *this;
      }

      constexpr chrono::year
      year() const noexcept
      { return this->_M_y; }

      constexpr chrono::month
      month() const noexcept
      { return this->_M_m; }

      constexpr chrono::weekday
      weekday() const noexcept
      { return this->_M_wdl.weekday(); }

      constexpr chrono::weekday_last
      weekday_last() const noexcept
      { return this->_M_wdl; }

      constexpr
      operator sys_days() const noexcept
      {
        const auto __d = sys_days(this->_M_y / this->_M_m / last);
        return sys_days{(__d - (chrono::weekday{__d}
			     - this->_M_wdl.weekday())).time_since_epoch()};
      }

      explicit constexpr
      operator local_days() const noexcept
      { return local_days{sys_days{*this}.time_since_epoch()}; }

      constexpr bool
      ok() const noexcept
      { return this->_M_y.ok() && this->_M_m.ok() && this->_M_wdl.ok(); }
    };

    constexpr bool
    operator==(const year_month_weekday_last& __x,
	       const year_month_weekday_last& __y) noexcept
    {
      return __x.year() == __y.year()
	  && __x.month() == __y.month()
	  && __x.weekday_last() == __y.weekday_last();
    }

    constexpr bool
    operator!=(const year_month_weekday_last& __x,
	       const year_month_weekday_last& __y) noexcept
    { return !(__x == __y); }

    constexpr year_month_weekday_last
    operator+(const year_month_weekday_last& __ymwdl,
	      const months& __dm) noexcept
    { return (__ymwdl.year() / __ymwdl.month() + __dm) / __ymwdl.weekday_last(); }

    constexpr year_month_weekday_last
    operator+(const months& __dm,
	      const year_month_weekday_last& __ymwdl) noexcept
    { return __ymwdl + __dm; }

    constexpr year_month_weekday_last
    operator+(const year_month_weekday_last& __ymwdl,
	      const years& __dy) noexcept
    { return {__ymwdl.year() + __dy, __ymwdl.month(), __ymwdl.weekday_last()}; }

    constexpr year_month_weekday_last
    operator+(const years& __dy,
	      const year_month_weekday_last& __ymwdl) noexcept
    { return __ymwdl + __dy; }

    constexpr year_month_weekday_last
    operator-(const year_month_weekday_last& __ymwdl,
	      const months& __dm) noexcept
    { return __ymwdl + -__dm; }

    constexpr year_month_weekday_last
    operator-(const year_month_weekday_last& __ymwdl,
	      const years& __dy) noexcept
    { return __ymwdl + -__dy; }
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const year_month_weekday_last& __ymwdl);
*/
    // CALENDAR COMPOSITION OPERATORS

    constexpr year_month
    operator/(const year& __y, const month& __m) noexcept
    { return {__y, __m}; }

    constexpr year_month
    operator/(const year& __y, int __m) noexcept
    { return {__y, month(unsigned(__m))}; }

    constexpr month_day
    operator/(const month& __m, const day& __d) noexcept
    { return {__m, __d}; }

    constexpr month_day
    operator/(const month& __m, int __d) noexcept
    { return {__m, day(unsigned(__d))}; }

    constexpr month_day
    operator/(int __m, const day& __d) noexcept
    { return {month(unsigned(__m)), __d}; }

    constexpr month_day
    operator/(const day& __d, const month& __m) noexcept
    { return {__m, __d}; }

    constexpr month_day
    operator/(const day& __d, int __m) noexcept
    { return {month(unsigned(__m)), __d}; }

    constexpr month_day_last
    operator/(const month& __m, last_spec) noexcept
    { return month_day_last{__m}; }

    constexpr month_day_last
    operator/(int __m, last_spec) noexcept
    { return month(unsigned(__m)) / last; }

    constexpr month_day_last
    operator/(last_spec, const month& __m) noexcept
    { return __m / last; }

    constexpr month_day_last
    operator/(last_spec, int __m) noexcept
    { return __m / last; }

    constexpr month_weekday
    operator/(const month& __m, const weekday_indexed& __wdi) noexcept
    { return {__m, __wdi}; }

    constexpr month_weekday
    operator/(int __m, const weekday_indexed& __wdi) noexcept
    { return month(unsigned(__m)) / __wdi; }

    constexpr month_weekday
    operator/(const weekday_indexed& __wdi, const month& __m) noexcept
    { return __m / __wdi; }

    constexpr month_weekday
    operator/(const weekday_indexed& __wdi, int __m) noexcept
    { return __m / __wdi; }

    constexpr month_weekday_last
    operator/(const month& __m, const weekday_last& __wdl) noexcept
    { return {__m, __wdl}; }

    constexpr month_weekday_last
    operator/(int __m, const weekday_last& __wdl) noexcept
    { return month(unsigned(__m)) / __wdl; }

    constexpr month_weekday_last
    operator/(const weekday_last& __wdl, const month& __m) noexcept
    { return __m / __wdl; }

    constexpr month_weekday_last
    operator/(const weekday_last& __wdl, int __m) noexcept
    { return chrono::month(unsigned(__m)) / __wdl; }

    constexpr year_month_day
    operator/(const year_month& __ym, const day& __d) noexcept
    { return {__ym.year(), __ym.month(), __d}; }

    constexpr year_month_day
    operator/(const year_month& __ym, int __d) noexcept
    { return __ym / chrono::day{unsigned(__d)}; }

    constexpr year_month_day
    operator/(const year& __y, const month_day& __md) noexcept
    { return __y / __md.month() / __md.day(); }

    constexpr year_month_day
    operator/(int __y, const month_day& __md) noexcept
    { return chrono::year{__y} / __md; }

    constexpr year_month_day
    operator/(const month_day& __md, const year& __y) noexcept
    { return __y / __md; }

    constexpr year_month_day
    operator/(const month_day& __md, int __y) noexcept
    { return chrono::year(__y) / __md; }

    constexpr year_month_day_last
    operator/(const year_month& __ym, last_spec) noexcept
    { return {__ym.year(), month_day_last{__ym.month()}}; }

    constexpr year_month_day_last
    operator/(const year& __y, const month_day_last& __mdl) noexcept
    { return {__y, __mdl}; }

    constexpr year_month_day_last
    operator/(int __y, const month_day_last& __mdl) noexcept
    { return year(__y) / __mdl; }

    constexpr year_month_day_last
    operator/(const month_day_last& __mdl, const year& __y) noexcept
    { return __y / __mdl; }

    constexpr year_month_day_last
    operator/(const month_day_last& __mdl, int __y) noexcept
    { return year(__y) / __mdl; }

    constexpr year_month_weekday
    operator/(const year_month& __ym, const weekday_indexed& __wdi) noexcept
    { return {__ym.year(), __ym.month(), __wdi}; }

    constexpr year_month_weekday
    operator/(const year& __y, const month_weekday& __mwd) noexcept
    { return {__y, __mwd.month(), __mwd.weekday_indexed()}; }

    constexpr year_month_weekday
    operator/(int __y, const month_weekday& __mwd) noexcept
    { return year(__y) / __mwd; }

    constexpr year_month_weekday
    operator/(const month_weekday& __mwd, const year& __y) noexcept
    { return __y / __mwd; }

    constexpr year_month_weekday
    operator/(const month_weekday& __mwd, int __y) noexcept
    { return year(__y) / __mwd; }

    constexpr year_month_weekday_last
    operator/(const year_month& __ym, const weekday_last& __wdl) noexcept
    { return {__ym.year(), __ym.month(), __wdl}; }

    constexpr year_month_weekday_last
    operator/(const year& __y, const month_weekday_last& __mwdl) noexcept
    { return {__y, __mwdl.month(), __mwdl.weekday_last()}; }

    constexpr year_month_weekday_last
    operator/(int __y, const month_weekday_last& __mwdl) noexcept
    { return year(__y) / __mwdl; }

    constexpr year_month_weekday_last
    operator/(const month_weekday_last& __mwdl, const year& __y) noexcept
    { __y / __mwdl; }

    constexpr year_month_weekday_last
    operator/(const month_weekday_last& __mwdl, int __y) noexcept
    { year(__y) / __mwdl; }

    // TIME_OF_DAY

    template<typename _Duration>
      class time_of_day;

    template<>
      class time_of_day<hours>
      {
      public:

        using precision = chrono::hours;

        time_of_day() = default;

        explicit constexpr
        time_of_day(chrono::hours __since_midnight) noexcept;

        constexpr chrono::hours
        hours() const noexcept;

        explicit constexpr
        operator precision() const noexcept;

        constexpr precision
        to_duration() const noexcept;

        constexpr void
        make24() noexcept;

        constexpr void
        make12() noexcept;
      };

    template<>
      class time_of_day<minutes>
      {
      public:

        using precision = chrono::minutes;

        time_of_day() = default;

        explicit constexpr
        time_of_day(chrono::minutes __since_midnight) noexcept;

        constexpr chrono::hours
        hours() const noexcept;

        constexpr chrono::minutes
        minutes() const noexcept;

        explicit constexpr
        operator precision() const noexcept;

        constexpr precision
        to_duration() const noexcept;

        constexpr void
        make24() noexcept;

        constexpr void
        make12() noexcept;
      };

    template<>
      class time_of_day<seconds>
      {
        public:

        using precision = chrono::seconds;

        time_of_day() = default;

        explicit constexpr
        time_of_day(chrono::seconds __since_midnight) noexcept;

        constexpr chrono::hours
        hours() const noexcept;

        constexpr chrono::minutes
        minutes() const noexcept;

        constexpr chrono::seconds
        seconds() const noexcept;

        explicit constexpr
        operator precision() const noexcept;

        constexpr precision
        to_duration() const noexcept;

        constexpr void
        make24() noexcept;

        constexpr void
        make12() noexcept;
      };

    template<typename _Rep, typename _Period>
      class time_of_day<duration<_Rep, _Period>>;
/*
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const time_of_day<hours>& __t);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const time_of_day<minutes>& __t);

    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const time_of_day<seconds>& __t);

    template<typename _CharT, typename _Traits, typename _Rep, typename _Period>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	         const time_of_day<duration<_Rep, _Period>>& __t);
*/
#endif // C++20

    // @}
  } // namespace chrono

#if __cplusplus > 201103L

#define __cpp_lib_chrono_udls 201304

  inline namespace literals
  {
  /** ISO C++ 2014  namespace for suffixes for duration literals.
   *
   * These suffixes can be used to create `chrono::duration` values with
   * tick periods of hours, minutes, seconds, milliseconds, microseconds
   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written
   * as `5s` after making the suffix visible in the current scope.
   * The suffixes can be made visible by a using-directive or
   * using-declaration such as:
   *  - `using namespace std::chrono_literals;`
   *  - `using namespace std::literals;`
   *  - `using namespace std::chrono;`
   *  - `using namespace std;`
   *  - `using std::chrono_literals::operator""s;`
   *
   * The result of these suffixes on an integer literal is one of the
   * standard typedefs such as `std::chrono::hours`.
   * The result on a floating-point literal is a duration type with the
   * specified tick period and an unspecified floating-point representation,
   * for example `1.5e2ms` might be equivalent to
   * `chrono::duration<long double, chrono::milli>(1.5e2)`.
   *
   * @ingroup chrono
   */
  inline namespace chrono_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    /// @cond undocumented
    template<typename _Dur, char... _Digits>
      constexpr _Dur __check_overflow()
      {
	using _Val = __parse_int::_Parse_int<_Digits...>;
	constexpr typename _Dur::rep __repval = _Val::value;
	static_assert(__repval >= 0 && __repval == _Val::value,
		      "literal value cannot be represented by duration type");
	return _Dur(__repval);
      }
    /// @endcond

    /// Literal suffix for durations representing non-integer hours
    constexpr chrono::duration<long double, ratio<3600,1>>
    operator""h(long double __hours)
    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }

    /// Literal suffix for durations of type `std::chrono::hours`
    template <char... _Digits>
      constexpr chrono::hours
      operator""h()
      { return __check_overflow<chrono::hours, _Digits...>(); }

    /// Literal suffix for durations representing non-integer minutes
    constexpr chrono::duration<long double, ratio<60,1>>
    operator""min(long double __mins)
    { return chrono::duration<long double, ratio<60,1>>{__mins}; }

    /// Literal suffix for durations of type `std::chrono::minutes`
    template <char... _Digits>
      constexpr chrono::minutes
      operator""min()
      { return __check_overflow<chrono::minutes, _Digits...>(); }

    /// Literal suffix for durations representing non-integer seconds
    constexpr chrono::duration<long double>
    operator""s(long double __secs)
    { return chrono::duration<long double>{__secs}; }

    /// Literal suffix for durations of type `std::chrono::seconds`
    template <char... _Digits>
      constexpr chrono::seconds
      operator""s()
      { return __check_overflow<chrono::seconds, _Digits...>(); }

    /// Literal suffix for durations representing non-integer milliseconds
    constexpr chrono::duration<long double, milli>
    operator""ms(long double __msecs)
    { return chrono::duration<long double, milli>{__msecs}; }

    /// Literal suffix for durations of type `std::chrono::milliseconds`
    template <char... _Digits>
      constexpr chrono::milliseconds
      operator""ms()
      { return __check_overflow<chrono::milliseconds, _Digits...>(); }

    /// Literal suffix for durations representing non-integer microseconds
    constexpr chrono::duration<long double, micro>
    operator""us(long double __usecs)
    { return chrono::duration<long double, micro>{__usecs}; }

    /// Literal suffix for durations of type `std::chrono::microseconds`
    template <char... _Digits>
      constexpr chrono::microseconds
      operator""us()
      { return __check_overflow<chrono::microseconds, _Digits...>(); }

    /// Literal suffix for durations representing non-integer nanoseconds
    constexpr chrono::duration<long double, nano>
    operator""ns(long double __nsecs)
    { return chrono::duration<long double, nano>{__nsecs}; }

    /// Literal suffix for durations of type `std::chrono::nanoseconds`
    template <char... _Digits>
      constexpr chrono::nanoseconds
      operator""ns()
      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }

#if __cplusplus > 201703L
    constexpr chrono::day
    operator""d(unsigned long long __d) noexcept
    { return chrono::day{static_cast<unsigned>(__d)}; }

    constexpr chrono::year
    operator""y(unsigned long long __y) noexcept
    { return chrono::year{static_cast<int>(__y)}; }
#endif // C++20

#pragma GCC diagnostic pop
  } // inline namespace chrono_literals
  } // inline namespace literals

  namespace chrono
  {
    using namespace literals::chrono_literals;
  } // namespace chrono

#if __cplusplus >= 201703L
  namespace filesystem
  {
    struct __file_clock
    {
      using duration                  = chrono::nanoseconds;
      using rep                       = duration::rep;
      using period                    = duration::period;
      using time_point                = chrono::time_point<__file_clock>;
      static constexpr bool is_steady = false;

      static time_point
      now() noexcept
      { return _S_from_sys(chrono::system_clock::now()); }

#if __cplusplus > 201703L
      template<typename _Dur>
	static
	chrono::file_time<_Dur>
	from_sys(const chrono::sys_time<_Dur>& __t) noexcept
	{ return _S_from_sys(__t); }

      // For internal use only
      template<typename _Dur>
	static
	chrono::sys_time<_Dur>
	to_sys(const chrono::file_time<_Dur>& __t) noexcept
	{ return _S_to_sys(__t); }
#endif // C++20

    private:
      using __sys_clock = chrono::system_clock;

      // This clock's (unspecified) epoch is 2174-01-01 00:00:00 UTC.
      // A signed 64-bit duration with nanosecond resolution gives roughly
      // +/- 292 years, which covers the 1901-2446 date range for ext4.
      static constexpr chrono::seconds _S_epoch_diff{6437664000};

    protected:
      // For internal use only
      template<typename _Dur>
	static
	chrono::time_point<__file_clock, _Dur>
	_S_from_sys(const chrono::time_point<__sys_clock, _Dur>& __t) noexcept
	{
	  using __file_time = chrono::time_point<__file_clock, _Dur>;
	  return __file_time{__t.time_since_epoch()} - _S_epoch_diff;
	}

      // For internal use only
      template<typename _Dur>
	static
	chrono::time_point<__sys_clock, _Dur>
	_S_to_sys(const chrono::time_point<__file_clock, _Dur>& __t) noexcept
	{
	  using __sys_time = chrono::time_point<__sys_clock, _Dur>;
	  return __sys_time{__t.time_since_epoch()} + _S_epoch_diff;
	}
    };
  } // namespace filesystem
#endif // C++17
#endif // C++14

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++11

#endif //_GLIBCXX_CHRONO
